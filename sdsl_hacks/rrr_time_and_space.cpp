#include <iostream>
#include <fstream>
#include <string>
#include "sdsl/bit_vectors.hpp"
#include "counters.hpp"
#ifdef HACK
    #include HACK
#elif defined RRR15
    #include "sdsl/rrr_vector_15.hpp"
#endif

using namespace std;
using namespace sdsl;

#ifndef BLOCK_SIZE
#define BLOCK_SIZE 31
#endif

#ifndef RANK_SAMPLE_DENS
#define RANK_SAMPLE_DENS 32
#endif

using namespace std::chrono;
using timer = std::chrono::high_resolution_clock;

//! Performs random accesses on a vector and returns the sum of the accessed elements
/*! \param v     The container.
 *  \param rands Vector of locations which should be accessed. Length is a power of 2.
 *               Can be generated by method: util::rnd_positions<int_vector<64>>(log s, mask, v.size())
 *  \param mask  Mask which is used to perform the modulo s operation. See `rands`.
 *  \param times Number of iterations. If times > rands.size() array rands will be
 *               run through several times.
 */
template<class t_vec>
uint64_t test_random_access(const t_vec& v, const int_vector<64>& rands, uint64_t mask, uint64_t times=100000000)
{
    uint64_t cnt=0;
    for (uint64_t i=0; i<times; ++i) {
#ifdef HACK
        cnt += v.access(rands[i&mask]);
#else
        cnt += v[rands[ i&mask ]];
#endif
    }
    return cnt;
}

#ifdef HACK
template<class t_vec>
uint64_t test_rank(const t_vec& v, const int_vector<64>& rands, uint64_t mask, uint64_t times=100000000)
{
    uint64_t cnt=0;
    for (uint64_t i=0; i<times; ++i) {
        cnt += v.rank(rands[ i&mask ]);
    }
    return cnt;
}

template<class t_vec>
uint64_t test_select(const t_vec& v, const int_vector<64>& rands, uint64_t mask, uint64_t times=100000000)
{
    uint64_t cnt=0;
    for (uint64_t i=0; i<times; ++i) {
        cnt += v.select(rands[ i&mask ]);
    }
    return cnt;
}
#else
template<class t_vec>
uint64_t test_inv_random_access(const t_vec& v, const int_vector<64>& rands, uint64_t mask, uint64_t times=100000000)
{
    uint64_t cnt=0;
    for (uint64_t i=0; i<times; ++i) {
        cnt += v(rands[ i&mask ]);
    }
    return cnt;
}
#endif

int main(int argc, char* argv[])
{
    if (argc < 3) {
        cout << "Usage: " << argv[0] << " bit_vector_file" << endl;
        cout << " generates a rrr_vector<" << BLOCK_SIZE << "> with sample rate " << RANK_SAMPLE_DENS << endl;
        cout << " for the bitvector stored in bit_vector_file and run a benchmark" << endl;
        return 1;
    }

#ifdef HACK
    #ifndef CLASSNAME
        static_assert(false);
    #endif
    typedef CLASSNAME rrr_vec_type;
#elif defined HYB
    typedef hyb_vector<> rrr_vec_type;
    typedef rrr_vec_type::rank_1_type rrr_rank_type;
#elif defined RRR15
    typedef rrr_vector<15, int_vector<>, RANK_SAMPLE_DENS> rrr_vec_type;
    typedef rrr_vec_type::select_1_type rrr_select_type;
    typedef rrr_vec_type::rank_1_type rrr_rank_type;
#else
    typedef rrr_vector<BLOCK_SIZE, int_vector<>, RANK_SAMPLE_DENS> rrr_vec_type;
    typedef rrr_vec_type::select_1_type rrr_select_type;
    typedef rrr_vec_type::rank_1_type rrr_rank_type;
#endif
    bit_vector bv;
    if (load_from_file(bv, argv[1])) {
        cout << "# plain size bytes: " << size_in_bytes(bv) << endl;
        uint16_t k = atoi(argv[2]);
        auto start = timer::now();
        rrr_vec_type rrr_vector(bv);
        Counters<1> count;
        util::clear(bv);
#ifndef HACK
#ifndef HYB
        rrr_select_type rrr_sel(&rrr_vector);
#endif
        rrr_rank_type   rrr_rank(&rrr_vector);
#endif
        auto stop = timer::now();
        cout << "# construct time (ms): " << duration_cast<milliseconds>(stop-start).count() << endl;
#ifdef HACK
        uint64_t args = rrr_vector.rank(rrr_vector.size());
#else
        rrr_vec_type::size_type args = rrr_rank(rrr_vector.size());
#endif
        cout << "# rrr_vector elsms: " << rrr_vector.size() << endl;
        cout << "# one bits: " << args << endl;
        cout << "# file name: "  << argv[1] << endl;
        cout << "# block size: " << BLOCK_SIZE << endl;
        cout << "# rank sample rate: "<< k << endl;
#ifdef HACK
        cout << "# rrr size bytes: "   << rrr_vector.bytes_size() << endl;
#else
        cout << "# rrr size bytes: "   << size_in_bytes(rrr_vector) << endl;
#endif
#ifndef HYB
        cout << "#  C array bytes: "   << rrr_vector.C_bytes() << endl;
        cout << "#  F array bytes: "   << rrr_vector.F_bytes() << endl;
        cout << "#   partial sums: "   << rrr_vector.partial_sums() << endl;
        cout << "#   lookup bytes: "   << rrr_vector.lookup_tables() << endl;
        cout << "#   object bytes: "   << rrr_vector.object_bytes() << endl;
#endif
        const uint64_t reps = 10000000;
        uint64_t mask = 0;
        uint64_t check = 0;
        int_vector<64> rands = util::rnd_positions<int_vector<64>>(20, mask, rrr_vector.size(), 17);
        count.reset();
        start = timer::now();
        check = test_random_access(rrr_vector, rands, mask, reps);
        stop = timer::now();
        count.accumulate(0);
        cout << "# access time ns/query: " << duration_cast<nanoseconds>(stop-start).count()/(double)reps << endl;
        cout << "# access checksum: " << check << endl;
        auto c = count.get(0);
        cout << "Cycles:       " << c[0] << " (" << double(c[0]) / reps << ")" << "\n"
             << "Instructions: " << c[1] << " (" << double(c[1]) / reps << ")" << "\n"
             << "IPC:          " << (double(c[1]) / c[0]) << "\n"
             << "Branch miss:  " << c[2] << " (" << double(c[2]) / reps << ")" << "\n"
             << "cache misses: " << c[3] << " (" << double(c[3]) / reps << ")" << endl;
        rands = util::rnd_positions<int_vector<64>>(20, mask, rrr_vector.size()+1, 17);
        start = timer::now();
#ifdef HACK
        check = test_rank(rrr_vector, rands, mask, reps);
#else
        check = test_inv_random_access(rrr_rank, rands, mask, reps);
#endif
        stop = timer::now();
        cout << "# rank time ns/query: " << duration_cast<nanoseconds>(stop-start).count()/(double)reps << endl;
        cout << "# rank checksum: " << check << endl;
        rands = util::rnd_positions<int_vector<64>>(20, mask, args, 17);
        for (uint64_t i=0; i<rands.size(); ++i) rands[i] = rands[i]+1;
        stop = timer::now();
#ifdef HACK
        check = test_select(rrr_vector, rands, mask, reps);
#else
#ifndef HYB
        check = test_inv_random_access(rrr_sel, rands, mask, reps);
#endif
#endif
        stop = timer::now();
        cout << "# select time ns/query: " << duration_cast<nanoseconds>(stop-start).count()/(double)reps << endl;
        cout << "# select checksum: " << check << endl;
    }
}
